{"version":3,"sources":["game/StateExtensions.ts","game/Params.ts","game/BasicGame.ts","game/WorldStateExtensions.ts","game/GameScenario.ts","game/index.ts","util/constants.ts","components/CardView.tsx","components/Card.tsx","util/hooks.ts","components/Deck.tsx","components/Bar.tsx","components/Stats.tsx","components/Game.tsx","game/GameWorldLoader.ts","game/load-scenario.ts","App.tsx","index.tsx"],"names":["useRounds","state","params","vars","rounds","flags","createReducer","targetId","sourceIds","func","initialValue","stateValues","map","id","result","reduce","acc","value","createParameterCap","ids","min","max","undefined","Math","stateExtensionsFromData","modifiers","modifier","type","length","a","b","stateIds","flagIds","worldState","outState","outFlags","Object","keys","console","table","Error","hasMatchingParamQuery","worldQueries","some","q","entries","every","key","flag","isMatchingParamQuery","BasicGame","cards","stats","initialParams","options","_cards","_random","_tickModifiers","_stats","_initialParams","random","tickModifiers","this","action","nextState","_applyModifiers","card","_selectWeightedRandomFrom","_getAvailableCards","filter","c","match","array","weightFunc","element","weight","count","selectionList","push","selectionPosition","selectionIndex","findIndex","index","applyAction","s","worldStateExtensionFromStateExtension","extension","newState","BasicGameScenario","scenario","_scenario","_worldStateExtensions","worldStateExtensions","prevState","updatedWorld","getUpdatedWorld","getNextCard","inputModifiers","world","mod","updatedWorldState","updateWorldState","updatedWorldFlags","updateWorldFlags","applyWorldStateExtensions","currentWorldState","assign","defaultState","stateModifier","updatedState","newValue","currentWorldFlags","flagsModifier","updatedFlags","extensions","availableEvents","getAvailableEvents","event","selectNextEvent","_cardDataToCard","selectEventCard","initialEventCardId","selectNextCard","getAvailableCards","nextCard","eventCards","availableCards","nextEventCardId","eventStartingNow","hasOwnProperty","events","e","hasMatchingWorldQuery","isAvailableWhen","isMatchingWorldQuery","selectRandomFrom","probability","cardId","eventCard","floor","selectWeightedRandomFrom","data","image","title","text","location","actions","left","description","getUpdatedState","right","stat","getValue","getInitialCard","worldStateModifiers","SwipeDirection","cardSize","scale","cardWidth","theme","borderRadius","cardHeight","actionWidth","minActionWidth","largePadding","halfLargePadding","quadPadding","doublePadding","mediumPadding","halfPadding","locationPosition","CardContent","styled","div","props","cardBackImage","defaultProps","CardView","leftAction","rightAction","direction","className","style","backgroundImage","Left","Right","DummyCard","x","y","r","layer","position","transform","transition","zIndex","getThreshold","window","innerWidth","Card","callback","i","onSwipe","useSpring","rot","delay","to","from","cardAnimationState","setCardAnimationState","useState","directionPreview","setDirectionPreview","isGone","currentKey","cardState","gestureControl","args","down","xDelta","delta","velocity","distance","trigger","abs","devicePixelRatio","dir","sign","setTimeout","config","friction","tension","directionX","useEffect","downHandler","includes","upHandler","addEventListener","removeEventListener","bind","useGesture","interpolate","Number","loopingIndex","tick","Deck","cardStack","Array","apply","_","list","sin","Container","Value","Bar","header","Stat","Icon","Stats","gameIcon","icon","ioIcon","featherIcon","IconWidget","GameIcons","IoIcons","FeatherIcons","iconSize","size","Footer","footer","Game","game","initialState","setState","setTick","load","gameWorld","defaultParams","cardFromData","eventCardsFromData","eventFromData","parameterCaps","parameterCapsFromStats","statsFromData","stateExtensions","paramQueries","worldQueryToParamQuery","noPreviousCardSetter","propabilityHit","statVarIds","actionFromData","eventCardsData","eventCardChain","targetCard","defaultDescription","defaultVars","currentVars","updateVars","defaultFlags","currentFlags","updateFlags","updateParams","query","tryLoadFromLocalStorage","path","matchLocal","gameWorldId","serializedData","localStorage","getItem","JSON","parse","tryLoadFromRestAPI","statsPath","cardsPath","eventsPath","eventCardsPath","defaultStatePath","worldStateModifiersPath","Promise","all","fetchJSON","loadScenario","log","fetch","json","main","GlobalStyles","createGlobalStyle","App","useBasicGame","setGame","scenarioData","instance","fromData","GameWorldLoader","warn","fetchWorld","URLSearchParams","search","get","process","REACT_APP_SFF_DEFAULT_SCENARIO","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.8d5938f0.chunk.js","sourcesContent":["import { GameState, StateModifier, Params } from './'\nimport { WorldStateModifier } from './ContentTypes'\n\nexport type StateExtension = StateModifier<Params>\n\n/**\n * World state extension counting the number of sounds from game start\n *\n * @param worldState The world state on which to operate\n * @returns WorldState The updated world state\n */\nexport const useRounds: StateExtension = (state: GameState<Params>) => {\n    return {\n        ...state,\n        params: {\n            vars: {\n                ...state.params.vars,\n                rounds: (state.params.vars.rounds ?? 0) + 1,\n            },\n            flags: state.params.flags,\n        },\n    }\n}\n\n/**\n * Create a cyclic world state extension with a given state id\n *\n * @param id The id to which cyclic state is assigned\n * @param length The length of the cycle\n * @returns a state extesion that generates a cyclic param behaviour\n */\nexport function createCycle(id: string, length: number): StateExtension {\n    return (state: GameState<Params>) => {\n        return {\n            ...state,\n            params: {\n                vars: {\n                    ...state.params.vars,\n                    [id]: ((state.params.vars[id] ?? 0) + 1) % length,\n                },\n                flags: state.params.flags,\n            },\n        }\n    }\n}\n\n/**\n * Creates a reducer for world state parameters\n *\n * @param targetId The id of the state parameter that will receive the result\n * @param sourceIds The ids of the sources that are used in the reduction\n * @param func The reducer function\n * @param initialValue The initial value to the reducer\n * @returns A world state extension that reduces a single value from multiple sources\n */\nexport function createReducer(\n    targetId: string,\n    sourceIds: string[],\n    func: (a: number, b: number) => number,\n    initialValue?: number,\n): StateExtension {\n    return (state: GameState<Params>) => {\n        const params = state.params\n        const stateValues = sourceIds.map((id) => params.vars[id] ?? 0)\n        const result = initialValue\n            ? stateValues.reduce((acc, value) => func(acc, value), initialValue)\n            : stateValues.reduce((acc, value) => func(acc, value))\n        return {\n            ...state,\n            params: {\n                flags: state.params.flags,\n                vars: {\n                    ...state.params.vars,\n                    [targetId]: result,\n                },\n            },\n        }\n    }\n}\n\n/**\n * Creates a configured debug log extension that logs either the entire world state\n * or a number of specified state or flag parameters.\n *\n * @param worldState The world state on which to operate\n * @param stateIds Optional ids of the states to log\n * @param flagIds Optional ids of the flags to log\n * @returns A configured debug world state extension that logs state and flags to tables\n */\nexport function createDebugger(\n    stateIds?: string[],\n    flagIds?: string[],\n): StateExtension {\n    return (worldState: GameState<Params>) => {\n        const params = worldState.params\n        const outState =\n            stateIds === undefined\n                ? params.vars\n                : stateIds.reduce<Params['vars']>((acc, id) => {\n                      acc[id] = params.vars[id]\n                      return acc\n                  }, {})\n        const outFlags =\n            flagIds === undefined\n                ? params.flags\n                : flagIds.reduce<Params['flags']>((acc, id) => {\n                      acc[id] = params.flags[id]\n                      return acc\n                  }, {})\n        if (Object.keys(outState).length > 0) {\n            console.table(outState)\n        }\n        if (Object.keys(outFlags).length > 0) {\n            console.table(outFlags)\n        }\n        return worldState\n    }\n}\n\n/**\n * Cap a number of identified parameters to be contained within a range\n *\n * @param ids Ids of the params which to limit to the range [min, max]\n * @param min The minimum number of the range\n * @param max The maximum number of the range\n * @returns a state extension which caps params with ids to the range [min, max]\n */\nexport function createParameterCap(\n    ids: string[],\n    min: number,\n    max: number,\n): StateModifier<Params> {\n    return (state) => ({\n        ...state,\n        params: {\n            flags: state.params.flags,\n            vars: {\n                ...state.params.vars,\n                ...ids.reduce<Params['vars']>((acc, id) => {\n                    const value = state.params.vars[id]\n                    if (value !== undefined) {\n                        acc[id] = Math.max(min, Math.min(max, value))\n                    }\n                    return acc\n                }, {}),\n            },\n        },\n    })\n}\n\n/**\n * Generate a list of world state extension from a data description\n *\n * @param modifiers Data description of modifiers which can be converted to extensions\n */\nexport function stateExtensionsFromData(\n    modifiers: WorldStateModifier[],\n): StateExtension[] {\n    return modifiers.map((modifier) => {\n        switch (modifier.type) {\n            case 'round':\n                return useRounds\n            case 'cycle':\n                return createCycle(modifier.id, modifier.length)\n            case 'min':\n                return createReducer(\n                    modifier.targetId,\n                    modifier.sourceIds,\n                    (a, b) => Math.min(a, b),\n                )\n            case 'max':\n                return createReducer(\n                    modifier.targetId,\n                    modifier.sourceIds,\n                    (a, b) => Math.max(a, b),\n                )\n            case 'sum':\n                return createReducer(\n                    modifier.targetId,\n                    modifier.sourceIds,\n                    (a, b) => a + b,\n                    0,\n                )\n            case 'debug':\n                return createDebugger(modifier.stateIds, modifier.flagIds)\n            default:\n                throw new Error(\n                    'Missing modifier type: ' + (modifier as any).type,\n                ) // Hack to please the linter\n        }\n    })\n}\n","export type Params = {\n    vars: {\n        [id: string]: number\n    }\n    flags: {\n        [id: string]: boolean\n    }\n}\n\nexport type ParamQuery = {\n    vars?: {\n        [id: string]: [number, number]\n    }\n    flags?: {\n        [id: string]: boolean\n    }\n}\n\nexport function hasMatchingParamQuery(\n    params: Params,\n    worldQueries: ParamQuery[],\n): boolean {\n    return worldQueries.some((q) => isMatchingParamQuery(params, q))\n}\n\nexport function isMatchingParamQuery(\n    params: Params,\n    { vars = {}, flags = {} }: ParamQuery,\n): boolean {\n    const hasStateMatch = Object.entries(vars).every(\n        ([key, [min, max]]) =>\n            params.vars[key] >= min && params.vars[key] <= max,\n    )\n\n    const result =\n        hasStateMatch &&\n        Object.entries(flags).every(\n            ([flag, value]) => !!params.flags[flag] === value,\n        )\n\n    return result\n}\n","import { Game, GameState, StateModifier, Card, Stat } from './Types'\n\nexport type GameOptions<P> = {\n    random: () => number\n    tickModifiers: StateModifier<P>[]\n}\n\nexport class BasicGame<P> implements Game<P> {\n    protected _cards: Card<P>[]\n    protected _random: () => number\n    protected _tickModifiers: StateModifier<P>[]\n    protected _stats: Stat<P>[]\n    protected _initialParams: P\n\n    constructor(\n        cards: Card<P>[],\n        stats: Stat<P>[],\n        initialParams: P,\n        options: Partial<GameOptions<P>> = {},\n    ) {\n        const { random = Math.random, tickModifiers = [] } = options\n        this._cards = cards\n        this._random = random\n        this._tickModifiers = tickModifiers\n        this._initialParams = initialParams\n        this._stats = stats\n    }\n\n    get stats() {\n        return this._stats\n    }\n\n    get initialState(): GameState<P> {\n        return this.applyAction(\n            {\n                params: this._initialParams,\n            },\n            (s) => s,\n        )\n    }\n\n    applyAction(state: GameState<P>, action: StateModifier<P>): GameState<P> {\n        const nextState = this._applyModifiers(\n            {\n                ...state,\n                card: undefined,\n            },\n            [action, ...this._tickModifiers],\n        )\n        return nextState.card\n            ? nextState\n            : {\n                  ...nextState,\n                  card: this._selectWeightedRandomFrom(\n                      this._getAvailableCards(nextState),\n                  ),\n              }\n    }\n\n    private _applyModifiers(\n        state: GameState<P>,\n        modifiers: StateModifier<P>[],\n    ): GameState<P> {\n        return modifiers.reduce((acc, modifier) => modifier(acc), state)\n    }\n\n    private _getAvailableCards(state: GameState<P>): Card<P>[] {\n        return this._cards.filter((c) => c.match(state))\n    }\n\n    private _selectWeightedRandomFrom<T extends { weight: number }>(\n        array: T[],\n        weightFunc = (element: T) => element.weight,\n    ): T {\n        const { selectionList, count } = array.reduce<{\n            count: number\n            selectionList: number[]\n        }>(\n            (acc, element) => {\n                acc.count += weightFunc(element)\n                acc.selectionList.push(acc.count)\n                return acc\n            },\n            { count: 0, selectionList: [] },\n        )\n\n        const selectionPosition = this._random() * count\n        const selectionIndex = selectionList.findIndex((max, index, array) => {\n            const min = index > 0 ? array[index - 1] : 0\n            return selectionPosition >= min && selectionPosition <= max\n        })\n\n        return array[selectionIndex]\n    }\n}\n","import { WorldState, WorldStateModifier } from './ContentTypes'\nimport { StateExtension, stateExtensionsFromData } from './StateExtensions'\nimport { Params, GameState } from './'\n\nexport type WorldStateExtension = (worldState: WorldState) => WorldState\n\nfunction worldStateExtensionFromStateExtension(\n    extension: StateExtension,\n): WorldStateExtension {\n    return (worldState) => {\n        const state: GameState<Params> = {\n            params: {\n                vars: worldState.state,\n                flags: worldState.flags,\n            },\n        }\n        const newState = extension(state)\n\n        return {\n            state: newState.params.vars,\n            flags: newState.params.flags,\n        }\n    }\n}\n\n/**\n * Generate a list of world state extension from a data description\n *\n * @param modifiers Data description of modifiers which can be converted to extensions\n */\nexport function worldStateExtensionFromData(\n    modifiers: WorldStateModifier[],\n): WorldStateExtension[] {\n    return stateExtensionsFromData(modifiers).map(\n        worldStateExtensionFromStateExtension,\n    )\n}\n","import {\n    GameWorld,\n    WorldState,\n    WorldQuery,\n    GameWorldModifier,\n    WorldEvent,\n    CardData,\n    EventCard,\n    CardActionData,\n    EventCardActionData,\n    EventCardId,\n} from './ContentTypes'\nimport {\n    WorldStateExtension,\n    worldStateExtensionFromData,\n} from './WorldStateExtensions'\nimport { Card, Game, GameState, StateModifier, Stat } from './'\n\nexport type GameScenarioOptions = {\n    random: () => number\n    worldStateExtensions: WorldStateExtension[]\n}\n\ntype ScenarioState = GameState<WorldState>\n\n/**\n * BasicGameScenario used to simulate game scenarios.\n *\n * The design goal is to keep this stateless, allowing user code to manage state.\n */\nexport class BasicGameScenario implements Game<WorldState> {\n    protected _scenario: Omit<GameWorld, 'worldStateModifiers'>\n    protected _random: () => number\n    protected _worldStateExtensions: WorldStateExtension[]\n\n    constructor(\n        scenario: Omit<GameWorld, 'worldStateModifiers'>,\n        options: Partial<GameScenarioOptions> = {},\n    ) {\n        const { random = Math.random, worldStateExtensions = [] } = options\n        this._scenario = scenario\n        this._random = random\n        this._worldStateExtensions = worldStateExtensions\n    }\n\n    get stats(): Stat<WorldState>[] {\n        return this._scenario.stats.map<Stat<WorldState>>((stat) => ({\n            ...stat,\n            getValue: ({ params }) => params.state[stat.id],\n        }))\n    }\n\n    /**\n     * Get the initial state for a given scenario.\n     */\n    get initialState(): ScenarioState {\n        return {\n            params: this.applyWorldStateExtensions(\n                this._worldStateExtensions,\n                this._scenario.defaultState,\n            ),\n            card: this.getInitialCard(),\n        }\n    }\n\n    applyAction(\n        prevState: ScenarioState,\n        action: StateModifier<WorldState>,\n    ): ScenarioState {\n        return action(prevState)\n    }\n\n    /**\n     * Get the updated state for a scenario based on previous state and the action taken to move forward.\n     *\n     * Since all dependencies are clearly stated throughout all child functions,\n     * it's really easy to change partial data and state to get a different updated state.\n     * This could be really useful for testing, or perhaps even some kind of AI to find the optimal actions/strategy\n     *\n     * @param prevState The state before this update\n     * @param card The currently visible card that the player is acting upon\n     * @param action The player's choosen action for how to move forward in the game\n     */\n    getUpdatedState(\n        prevState: ScenarioState,\n        card: CardData | EventCard,\n        action: CardActionData | EventCardActionData,\n    ): ScenarioState {\n        const updatedWorld = this.getUpdatedWorld(\n            action.modifiers,\n            prevState.params,\n        )\n\n        return {\n            params: updatedWorld,\n            card: this.getNextCard(updatedWorld, card, action),\n        }\n    }\n\n    getUpdatedWorld(\n        inputModifiers: GameWorldModifier[],\n        world: WorldState,\n    ): WorldState {\n        const modifiers: GameWorldModifier[] = inputModifiers.map((mod) => ({\n            type: 'add',\n            state: {},\n            flags: {},\n            ...mod,\n        }))\n        const updatedWorldState = modifiers.reduce<WorldState['state']>(\n            (acc, mod) => this.updateWorldState(mod, { state: acc, flags: {} }),\n            world.state,\n        )\n        const updatedWorldFlags = modifiers.reduce<WorldState['flags']>(\n            (acc, mod) => this.updateWorldFlags(mod, { state: {}, flags: acc }),\n            world.flags,\n        )\n\n        const newWorld = this.applyWorldStateExtensions(\n            this._worldStateExtensions,\n            {\n                state: updatedWorldState,\n                flags: updatedWorldFlags,\n            },\n        )\n\n        return newWorld\n    }\n\n    updateWorldState(\n        modifier: GameWorldModifier,\n        world: WorldState,\n    ): WorldState['state'] {\n        const currentWorldState: WorldState['state'] =\n            modifier.type === 'replace'\n                ? Object.assign({}, this._scenario.defaultState.state)\n                : Object.assign({}, world.state)\n\n        const stateModifier = modifier.state || {}\n        const updatedWorldState = Object.entries(stateModifier).reduce<\n            WorldState['state']\n        >((updatedState: WorldState['state'], [key, value]) => {\n            const newValue =\n                modifier.type === 'set' || modifier.type === 'replace'\n                    ? value\n                    : value + (updatedState[key] || 0)\n\n            updatedState[key] = Math.min(Math.max(newValue, 0), 100)\n\n            return updatedState\n        }, currentWorldState)\n\n        return updatedWorldState\n    }\n\n    updateWorldFlags(\n        modifier: GameWorldModifier,\n        world: WorldState,\n    ): WorldState['flags'] {\n        const currentWorldFlags: WorldState['flags'] =\n            modifier.type === 'replace'\n                ? Object.assign({}, this._scenario.defaultState.flags)\n                : Object.assign({}, world.flags)\n\n        const flagsModifier = modifier.flags || {}\n        const updatedWorldFlags = Object.entries(flagsModifier).reduce<\n            WorldState['flags']\n        >((updatedFlags, [key, value]) => {\n            updatedFlags[key] = value\n            return updatedFlags\n        }, currentWorldFlags)\n\n        return updatedWorldFlags\n    }\n\n    applyWorldStateExtensions(\n        extensions: WorldStateExtension[],\n        world: WorldState,\n    ): WorldState {\n        return extensions.reduce((acc, extension) => extension(acc), world)\n    }\n\n    getInitialCard(): Card<WorldState> {\n        const availableEvents = this.getAvailableEvents(\n            this._scenario.defaultState,\n        )\n        const event = this.selectNextEvent(availableEvents)\n\n        return this._cardDataToCard(\n            event\n                ? this.selectEventCard(event.initialEventCardId)\n                : this.selectNextCard(\n                      this.getAvailableCards(this._scenario.defaultState),\n                  ),\n        )\n    }\n\n    getNextCard(\n        updatedWorld: WorldState,\n        card: CardData | EventCard,\n        action: CardActionData | EventCardActionData,\n    ): Card<WorldState> {\n        const { eventCards } = this._scenario\n        const availableEvents = this.getAvailableEvents(updatedWorld)\n        let availableCards: CardData[] = []\n\n        const nextEventCardId: string | null =\n            card.type === 'event' && 'nextEventCardId' in action\n                ? action.nextEventCardId\n                : null\n        const eventStartingNow = !nextEventCardId\n            ? this.selectNextEvent(availableEvents)\n            : null\n        let nextCard\n\n        // Only select the next EventCard if a specific one is given\n        // Else cancel the event and continue with normal cards.\n        if (nextEventCardId) {\n            if (!eventCards.hasOwnProperty(nextEventCardId)) {\n                throw new Error(\n                    `eventCardId \"${nextEventCardId}\" does not exist. Make sure it's spelled correctly`,\n                )\n            }\n            nextCard = this.selectEventCard(nextEventCardId)\n        } else if (eventStartingNow) {\n            nextCard = this.selectEventCard(eventStartingNow.initialEventCardId)\n        } else {\n            availableCards = this.getAvailableCards(updatedWorld)\n            nextCard = this.selectNextCard(availableCards)\n        }\n\n        if (!nextCard) throw new Error('Content error. No next card available.')\n        return this._cardDataToCard(nextCard)\n    }\n\n    getAvailableEvents(world: WorldState): WorldEvent[] {\n        const { events } = this._scenario\n        return events.filter((e) =>\n            this.hasMatchingWorldQuery(world, e.isAvailableWhen),\n        )\n    }\n\n    getAvailableCards(world: WorldState): CardData[] {\n        const { cards } = this._scenario\n        return cards.filter((c) =>\n            this.hasMatchingWorldQuery(world, c.isAvailableWhen),\n        )\n    }\n\n    hasMatchingWorldQuery(\n        world: WorldState,\n        worldQueries: WorldQuery[],\n    ): Boolean {\n        return worldQueries.some((q) => this.isMatchingWorldQuery(world, q))\n    }\n\n    isMatchingWorldQuery(\n        world: WorldState,\n        { state = {}, flags = {} }: WorldQuery,\n    ): Boolean {\n        const hasStateMatch = Object.entries(state).every(\n            ([key, [min, max]]) =>\n                world.state[key] >= min && world.state[key] <= max,\n        )\n\n        const result =\n            hasStateMatch &&\n            Object.entries(flags).every(\n                ([flag, value]) => !!world.flags[flag] === value,\n            )\n\n        return result\n    }\n\n    selectNextEvent(events: WorldEvent[] = []): WorldEvent | undefined {\n        const event = this.selectRandomFrom(events)\n        if (event && this._random() <= event.probability) {\n            return event\n        }\n    }\n\n    selectEventCard(cardId: EventCardId): EventCard {\n        const eventCard = this._scenario.eventCards[cardId]\n        if (!eventCard)\n            throw new Error(\n                `ContentError: EventCard with EventCardId \"${cardId}\" does not exist`,\n            )\n        return eventCard\n    }\n\n    selectRandomFrom<T>(array: T[]): T {\n        return array[Math.floor(this._random() * array.length)]\n    }\n\n    selectNextCard(cards: CardData[] = []): CardData {\n        return this.selectWeightedRandomFrom(cards)\n    }\n\n    selectWeightedRandomFrom<T extends { weight: number }>(\n        array: T[],\n        weightFunc = (element: T) => element.weight,\n    ): T {\n        const { selectionList, count } = array.reduce<{\n            count: number\n            selectionList: number[]\n        }>(\n            (acc, element) => {\n                acc.count += weightFunc(element)\n                acc.selectionList.push(acc.count)\n                return acc\n            },\n            { count: 0, selectionList: [] },\n        )\n\n        const selectionPosition = this._random() * count\n        const selectionIndex = selectionList.findIndex((max, index, array) => {\n            const min = index > 0 ? array[index - 1] : 0\n            return selectionPosition >= min && selectionPosition <= max\n        })\n\n        return array[selectionIndex]\n    }\n\n    private _cardDataToCard<T extends CardData | EventCard>(\n        data: T,\n    ): Card<WorldState> {\n        return {\n            image: data.image ?? '',\n            title: data.title ?? '',\n            text: data.text ?? '',\n            location: data.location ?? '',\n            match: () => true,\n            weight: data.weight ?? 1,\n            actions: {\n                left: {\n                    description: data.actions.left.description ?? 'No',\n                    modifier: (state) => {\n                        return this.getUpdatedState(\n                            state,\n                            data,\n                            data.actions.left,\n                        )\n                    },\n                },\n                right: {\n                    description: data.actions.right.description ?? 'Yes',\n                    modifier: (state) => {\n                        return this.getUpdatedState(\n                            state,\n                            data,\n                            data.actions.right,\n                        )\n                    },\n                },\n            },\n        }\n    }\n\n    /**\n     * Create a runtime GameScenario from data\n     *\n     * @param data Data needed to setup a basic game scenario\n     */\n    public static fromData(data: GameWorld): Game<WorldState> {\n        const extensions = worldStateExtensionFromData(data.worldStateModifiers)\n        return new BasicGameScenario(data, { worldStateExtensions: extensions })\n    }\n}\n","export * from './Types'\nexport * from './BasicGame'\nexport * from './Params'\nexport * from './StateExtensions'\nexport * from './GameScenario'\n","export enum SwipeDirection {\n    Left = -1,\n    Right = 1,\n}\n","import React from 'react'\nimport styled from 'styled-components/macro'\nimport { SwipeDirection } from '../util/constants'\n\ntype DummyCardProps = {\n    x: number\n    y: number\n    r: number\n    layer: number\n}\n\ntype CardProps = {\n    image: string\n    title: string\n    text: string\n    location: string\n    leftAction?: string\n    rightAction?: string\n    direction?: SwipeDirection\n}\n\nfunction cardSize(\n    scale: number,\n): (props: { theme: { cardWidth: (s: number) => string } }) => string {\n    return ({\n        theme: { cardWidth },\n    }: {\n        theme: { cardWidth: (s: number) => string }\n    }) => cardWidth(scale)\n}\n\nconst borderRadius = cardSize(0.035)\nconst cardWidth = cardSize(1)\nconst cardHeight = cardSize(2)\nconst actionWidth = cardSize(0.5)\nconst minActionWidth = cardSize(0.25)\nconst largePadding = cardSize(0.125)\nconst halfLargePadding = cardSize(0.0625)\nconst quadPadding = cardSize(0.1)\nconst doublePadding = cardSize(0.05)\nconst mediumPadding = cardSize(0.025)\nconst halfPadding = cardSize(0.0125)\nconst locationPosition = cardSize(-0.1125)\n\nconst CardContent = styled.div`\n    font-size: ${borderRadius};\n\n    & > .action-left,\n    & > .action-right {\n        font-size: 160%;\n        background: #fff;\n        position: absolute;\n        overflow: hidden;\n        top: 20%;\n        max-width: ${actionWidth};\n        min-width: ${minActionWidth};\n\n        padding: 0;\n        opacity: 0;\n        transition: transform 0.2s, opacity 0.2s;\n        transform: translateX(0%) scale(0.7);\n        box-shadow: 0 12.5px 20px -10px rgba(50, 50, 73, 0.4),\n            0 10px 10px -10px rgba(50, 50, 73, 0.3);\n\n        & > .description {\n            padding: ${mediumPadding};\n            text-align: center;\n        }\n\n        & > .arrow {\n            background: #333;\n            font-size: 160%;\n            color: #fff;\n            padding-left: ${mediumPadding};\n            padding-right: ${mediumPadding};\n        }\n    }\n\n    & > .action-right {\n        left: 0;\n        border-radius: ${borderRadius};\n\n        & > .arrow {\n            text-align: right;\n        }\n    }\n\n    & > .action-left {\n        right: 0;\n        border-radius: ${borderRadius};\n    }\n\n    & > .action-right.active {\n        transform: translateX(-50%) scale(1);\n        opacity: 1;\n    }\n\n    & > .action-left.active {\n        transform: translateX(50%) scale(1);\n        opacity: 1;\n    }\n\n    & > .card-view {\n        display: block;\n        will-change: transform;\n        position: relative;\n        width: ${cardWidth};\n        height: ${cardHeight};\n        border-radius: ${borderRadius};\n        box-shadow: 0 12.5px 20px -10px rgba(50, 50, 73, 0.4),\n            0 10px 10px -10px rgba(50, 50, 73, 0.3);\n        overflow: hidden;\n        background: #fff;\n\n        & > .card-image {\n            width: 100%;\n            height: 70%;\n            background-repeat: no-repeat;\n            background-position: center center;\n            background-size: auto 120%;\n            border: solid ${borderRadius} #fff;\n            border-style: solid solid none solid;\n        }\n\n        & > .card-text {\n            position: absolute;\n            bottom: 0;\n            left: 0;\n            width: 100%;\n            min-height: 30%;\n            background: #fff;\n\n            & > em.location {\n                position: absolute;\n                top: ${locationPosition};\n                right: 0;\n                display: block;\n                font-size: 140%;\n                background: rgba(230, 230, 230, 0.7);\n                border-radius: 1vh 0 0 1vh;\n                padding: ${halfPadding} ${largePadding} ${halfPadding}\n                    ${doublePadding};\n            }\n\n            & > h1.title {\n                font-size: 160%;\n                white-space: nowrap;\n                color: #fff;\n                background: #333;\n                display: block;\n                margin: 0;\n                padding: ${mediumPadding} ${halfLargePadding};\n            }\n\n            & > p.text {\n                font-size: 160%;\n                color: #333;\n                padding: ${doublePadding} ${halfLargePadding} ${quadPadding}\n                    ${halfLargePadding};\n                margin: 0;\n            }\n        }\n\n        & > .card-back {\n            width: 100%;\n            height: 100%;\n            border: solid ${borderRadius} #fff;\n            box-sizing: border-box;\n            background: url(${(props) => props.theme.cardBackImage});\n            background-size: auto 100%;\n            background-repeat: repeat;\n            background-position: center center;\n        }\n    }\n`\nCardContent.defaultProps = {\n    theme: {\n        cardWidth: (value: number) => value * 40 + 'vh',\n        cardBackImage:\n            'https://images.unsplash.com/photo-1550537687-c91072c4792d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=800&q=80',\n    },\n}\n\nexport const CardView: React.SFC<CardProps> = ({\n    image,\n    title,\n    text,\n    location,\n    leftAction,\n    rightAction,\n    direction,\n}) => (\n    <CardContent>\n        <div className=\"card-view\">\n            <div\n                className=\"card-image\"\n                style={{\n                    backgroundImage: 'url(' + (image ? image : '') + ')',\n                }}\n            ></div>\n            <div className=\"card-text\">\n                {location && <em className=\"location\">{location}</em>}\n                <h1 className=\"title\">{title}</h1>\n                <p className=\"text\">{text}</p>\n            </div>\n        </div>\n        <div\n            className={\n                'action-left' +\n                (direction === SwipeDirection.Left ? ' active' : '')\n            }\n        >\n            <div className=\"description\">{leftAction ?? 'No'}</div>\n            <div className=\"arrow\">&larr;</div>\n        </div>\n        <div\n            className={\n                'action-right' +\n                (direction === SwipeDirection.Right ? ' active' : '')\n            }\n        >\n            <div className=\"description\">{rightAction ?? 'Yes'}</div>\n            <div className=\"arrow\">&rarr;</div>\n        </div>\n    </CardContent>\n)\n\nexport const DummyCard: React.FunctionComponent<DummyCardProps> = ({\n    x,\n    y,\n    r = 0,\n    layer,\n}) => (\n    <div\n        style={{\n            position: 'absolute',\n            left: '50%',\n            transform: `translate3d(-50%, 0, 0) translate3d(${x * 0.15}vh, ${\n                y * 0.15\n            }vh, 0) perspective(1500px) rotate3d(1, 0, 0, 30deg) rotate3d(0, 0, 1, ${r}deg)`,\n            transition: 'transform 0.3s',\n            zIndex: layer,\n        }}\n    >\n        <CardContent>\n            <div className=\"card-view\">\n                <div className=\"card-back\"></div>\n            </div>\n        </CardContent>\n    </div>\n)\n","import React, { useState } from 'react'\nimport { CardView } from './CardView'\n\nimport { animated, interpolate } from 'react-spring'\nimport { useSpring } from 'react-spring'\nimport { useGesture, GestureState } from 'react-with-gesture'\n\nimport { useKeyboardEvent } from '../util/hooks'\nimport { SwipeDirection } from '../util/constants'\nimport { CardPresentation } from '../game/Types'\n\ntype AnimationState = {\n    x: number\n    y: number\n    scale: number\n    rot: number\n    delay?: number\n}\n\nconst to = (i: number): AnimationState => ({\n    x: 0,\n    y: -30,\n    scale: 1,\n    rot: 0,\n    delay: i * 100,\n})\nconst from = (): AnimationState => ({ rot: 0, scale: 1.0, y: -20, x: 0 })\n\nconst trans = (r: number, s: number) =>\n    `perspective(1500px) rotate3d(1, 0, 0, 30deg) rotate3d(0, 0, 1, ${r}deg) scale(${s})`\n\nconst getDeltaX = () => getThreshold() / window.devicePixelRatio\n\nconst getThreshold = () => Math.min(200, window.innerWidth / 2)\n\ntype CardProps = {\n    i: number\n    card: CardPresentation\n    onSwipe: (direction: SwipeDirection) => void\n    layer: number\n}\n\nexport const Card: React.FunctionComponent<CardProps> = ({\n    i,\n    card,\n    onSwipe,\n    layer,\n}) => {\n    const { title, location, text, image, actions } = card\n\n    const [cardAnimationState, setCardAnimationState] = useSpring(() => ({\n        ...to(i),\n        from: from(),\n    }))\n    const [directionPreview, setDirectionPreview] = useState<number>(0)\n\n    const [cardState] = useState<{\n        isGone: boolean\n        currentKey: string | null\n    }>({ isGone: false, currentKey: null })\n\n    const gestureControl: (\n        state: Pick<\n            GestureState,\n            'args' | 'down' | 'delta' | 'distance' | 'direction' | 'velocity'\n        >,\n    ) => void = ({\n        args: [index],\n        down,\n        delta: [xDelta],\n        distance,\n        direction: [xDir],\n        velocity,\n    }) => {\n        const trigger =\n            Math.abs(xDelta) * window.devicePixelRatio > getThreshold()\n        const dir = Math.sign(xDelta)\n\n        if (!down && trigger && !cardState.isGone) {\n            // Handle game state updates\n            cardState.isGone = true\n            window.setTimeout(() => {\n                onSwipe(dir)\n                cardState.currentKey = null\n            }, 200)\n        }\n        setDirectionPreview(down ? dir : 0)\n        const isGone = cardState.isGone\n\n        const x = isGone ? (200 + window.innerWidth) * dir : down ? xDelta : 0\n\n        const rot = xDelta / 100 + (isGone ? dir * 10 * velocity : 0)\n        const scale = down ? 1.1 : 1\n\n        const animationState = {\n            x,\n            rot,\n            scale,\n            delay: undefined,\n            config: {\n                friction: 50,\n                tension: down ? 800 : isGone ? 200 : 500,\n            },\n        }\n\n        setCardAnimationState(animationState)\n    }\n\n    useKeyboardEvent(['ArrowLeft', 'ArrowRight'], (down, key) => {\n        if (down && !cardState.currentKey) {\n            cardState.currentKey = key\n        }\n        if (cardState.currentKey === key) {\n            const directionX =\n                key === 'ArrowLeft' ? SwipeDirection.Left : SwipeDirection.Right\n            gestureControl({\n                down,\n                delta: [directionX * (getDeltaX() + 1), 0],\n                direction: [directionX, 0],\n                args: [0],\n                distance: 0,\n                velocity: 5,\n            })\n        }\n    })\n\n    const bind = useGesture((args) => {\n        if (!cardState.currentKey) gestureControl(args)\n    })\n\n    const { x, y, rot, scale } = cardAnimationState\n\n    return (\n        <animated.div\n            {...bind(i)}\n            key={i}\n            style={{\n                position: 'absolute',\n                left: '50%',\n                transform: interpolate(\n                    [x, y, rot, scale as any],\n                    (x: number, y: number, rot: number, scale: number) =>\n                        `translate3d(-50%, 0, 0) translate3d(${x * 0.15}vh,${\n                            y * 0.15\n                        }vh,0) ` + trans(rot, Number(scale)),\n                ),\n                zIndex: layer,\n            }}\n        >\n            <CardView\n                image={image}\n                title={title}\n                text={text}\n                location={location}\n                leftAction={actions.left.description}\n                rightAction={actions.right.description}\n                direction={directionPreview}\n            />\n        </animated.div>\n    )\n}\n","import { useEffect } from 'react'\n\nexport const useKeyboardEvent = (\n    keys: string[],\n    callback: (down: boolean, key: string) => void,\n) => {\n    useEffect(() => {\n        const downHandler = function (event: KeyboardEvent) {\n            if (keys.includes(event.key)) {\n                callback(true, event.key)\n            }\n        }\n        const upHandler = function (event: KeyboardEvent) {\n            if (keys.includes(event.key)) {\n                callback(false, event.key)\n            }\n        }\n        window.addEventListener('keydown', downHandler)\n        window.addEventListener('keyup', upHandler)\n        return () => {\n            window.removeEventListener('keydown', downHandler)\n            window.removeEventListener('keyup', upHandler)\n        }\n    })\n}\n","import React from 'react'\n\nimport { Card } from './Card'\nimport { DummyCard } from './CardView'\nimport { SwipeDirection } from '../util/constants'\nimport { CardPresentation } from '../game/Types'\n\ntype DeckProps = {\n    onSwipe: (direction: SwipeDirection) => void\n    card: CardPresentation\n    tick: number\n}\nconst Deck: React.FunctionComponent<DeckProps> = ({\n    onSwipe,\n    card,\n    tick = 0,\n}) => {\n    const cardStack = Array.apply(null, Array(5)).map((_, index) => index)\n    return (\n        <div className=\"deck-root\">\n            {cardStack.map((key, index, list) => (\n                <DummyCard\n                    x={0}\n                    y={\n                        -20 +\n                        list[loopingIndex(index, list.length, tick)] *\n                            (50 / list.length)\n                    }\n                    key={index}\n                    r={Math.sin(key * 2345) * 1}\n                    layer={list.length - loopingIndex(index, list.length, tick)}\n                />\n            ))}\n            <Card\n                i={0}\n                key={tick}\n                card={card}\n                onSwipe={onSwipe}\n                layer={cardStack.length + 1}\n            />\n        </div>\n    )\n}\n\nfunction loopingIndex(index: number, length: number, tick: number) {\n    const result = (length + index - (tick % length)) % length\n    return result\n}\n\nexport default Deck\n","import React from 'react'\nimport styled from 'styled-components/macro'\n\nconst Container = styled.div`\n    width: 5vh;\n    height: 1vh;\n    background: #333;\n    box-shadow: 0 0.2vh 0.2vh rgba(0, 0, 0, 0.2);\n`\n\nconst Value = styled.div<{ value: number }>`\n    width: ${(props) => props.value + '%'};\n    position: relative;\n    height: 100%;\n    background: #fff;\n`\n\ntype BarProps = {\n    value: number\n}\n\nconst Bar: React.FunctionComponent<BarProps> = ({ value = 100 }) => (\n    <Container>\n        <Value value={value} />\n    </Container>\n)\n\nexport default Bar\n","import React from 'react'\nimport styled from 'styled-components/macro'\n\n// This could prove to be a hit in binary size since we require all the icons in each pack. This compromise allows for more dynamic content.\nimport * as IoIcons from 'react-icons/io'\nimport * as GameIcons from 'react-icons/gi'\nimport * as FeatherIcons from 'react-icons/fi'\n\nimport Bar from './Bar'\nimport { StatDefinition } from '../game/ContentTypes'\n\nconst Container = styled.header`\n    background: #66aa55;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    flex-basis: 10vh;\n    flex-grow: 0;\n    flex-shrink: 0;\n    border-bottom: solid 0.5vh #fff;\n    box-shadow: 0 0.2vh 0.5vh rgba(0, 0, 0, 0.5);\n`\n\nconst Stat = styled.div`\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-direction: column;\n    margin-right: 3.5vh;\n\n    &:last-child {\n        margin-right: 0;\n    }\n`\n\nconst Icon = styled.div`\n    width: 5vh;\n    height: 5vh;\n    border-radius: 50% 0;\n    background: #fff;\n\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    box-shadow: 0 0.3vh 0.3vh rgba(0, 0, 0, 0.2);\n    margin-bottom: 1vh;\n`\ntype StatsProps = {\n    stats: (StatDefinition & { value: number })[]\n}\n\nconst Stats: React.FunctionComponent<StatsProps> = ({ stats }) => (\n    <Container>\n        {stats.map((s) => {\n            const gameIcon = s.icon as keyof typeof GameIcons\n            const ioIcon = s.icon as keyof typeof IoIcons\n            const featherIcon = s.icon as keyof typeof FeatherIcons\n            const IconWidget =\n                GameIcons[gameIcon] ||\n                IoIcons[ioIcon] ||\n                FeatherIcons[featherIcon]\n            const iconSize = s.iconSize || '80%'\n            const value = s.value\n            return (\n                <Stat key={s.id}>\n                    <Icon>{IconWidget && <IconWidget size={iconSize} />}</Icon>\n                    <Bar value={value} />\n                </Stat>\n            )\n        })}\n    </Container>\n)\n\nexport default Stats\n","import React, { useState } from 'react'\nimport styled from 'styled-components/macro'\n\nimport Deck from './Deck'\nimport Stats from './Stats'\nimport { SwipeDirection } from '../util/constants'\nimport { GameState, Game as GameLogic } from '../game/Types'\n\nconst Footer = styled.footer`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`\n\ntype GameProps<P> = {\n    game: GameLogic<P>\n}\n\nfunction Game<P>({ game }: GameProps<P>): React.ReactElement<any, any> | null {\n    const [state, setState] = useState<GameState<P>>(() => game.initialState)\n    const [tick, setTick] = useState<number>(0)\n\n    const stats = game.stats.map((stat) =>\n        Object.assign({}, stat, {\n            value: stat.getValue(state),\n        }),\n    )\n\n    function onSwipe(direction: SwipeDirection): void {\n        if (!state.card) return\n\n        const action =\n            direction === SwipeDirection.Left\n                ? state.card.actions.left.modifier\n                : state.card.actions.right.modifier\n\n        setState(game.applyAction(state, action))\n        setTick(tick + 1)\n    }\n\n    return (\n        <>\n            <Stats stats={stats} />\n            {state.card ? (\n                <Deck onSwipe={onSwipe} card={state.card} tick={tick} />\n            ) : null}\n            <Footer>\n                <div className=\"time-remaining\"></div>\n            </Footer>\n        </>\n    )\n}\n\nexport default Game\n","import {\n    GameWorld,\n    GameWorldModifier,\n    CardActionData,\n    EventCardActionData,\n    WorldQuery,\n} from './ContentTypes'\nimport { Game, GameState, Card, CardAction, StateModifier, Stat } from './Types'\nimport { Params, ParamQuery, hasMatchingParamQuery } from './Params'\nimport { BasicGame } from './BasicGame'\nimport { stateExtensionsFromData, createParameterCap } from './StateExtensions'\n\n/**\n * Loads a GameWorld object as a Game<Params>.\n * Uses the data structures to generate a runtime description of the game model.\n *\n * @param gameWorld The data definition of the game world\n * @param random A function used for generating random values between 0 and 1\n * @returns A Game<Params> object which uses the given data\n */\nexport function load(\n    gameWorld: GameWorld,\n    random: () => number = Math.random,\n): Game<Params> {\n    const defaultParams = {\n        flags: gameWorld.defaultState.flags,\n        vars: gameWorld.defaultState.state,\n    }\n    const cards = gameWorld.cards.map<Card<Params>>((data) =>\n        cardFromData(data, defaultParams),\n    )\n    const eventCards = eventCardsFromData(gameWorld.eventCards, defaultParams)\n    const events: StateModifier<Params>[] = gameWorld.events.map((event) => {\n        const card = eventCards[event.initialEventCardId]\n        return eventFromData(event, card, random)\n    })\n    const parameterCaps = parameterCapsFromStats(gameWorld.stats)\n    const stats = statsFromData(gameWorld.stats)\n    const stateExtensions = stateExtensionsFromData(\n        gameWorld.worldStateModifiers,\n    )\n    return new BasicGame<Params>([...cards], stats, defaultParams, {\n        tickModifiers: [...events, ...stateExtensions, parameterCaps],\n        random,\n    })\n}\n\n/**\n * Creates a StateModifier representing an event using data from GameWorld\n *\n * @param event The event data\n * @param card The card to which the event should be linked\n * @param random The random function used for the probability check\n * @returns An event trigger in the form of a StateModifier\n */\nfunction eventFromData(\n    event: GameWorld['events'][number],\n    card: Card<Params>,\n    random: () => number,\n): StateModifier<Params> {\n    const paramQueries = event.isAvailableWhen.map(worldQueryToParamQuery)\n    return (state) => {\n        const noPreviousCardSetter = !state.card\n        const propabilityHit = random() <= event.probability\n        const shouldExecute =\n            noPreviousCardSetter &&\n            propabilityHit &&\n            hasMatchingParamQuery(state.params, paramQueries)\n        return shouldExecute\n            ? {\n                  ...state,\n                  card: card,\n              }\n            : state\n    }\n}\n\n/**\n * Creates a list of Stat<Params> from GameWorld data\n *\n * @param stats The stats data\n * @returns A list of Stats\n */\nfunction statsFromData(stats: GameWorld['stats']): Stat<Params>[] {\n    return stats.map<Stat<Params>>((stat) => ({\n        ...stat,\n        getValue: ({ params }) => params.vars[stat.id] ?? 0,\n    }))\n}\n\n/**\n * Creates the standard parameters caps used for a standard GameWorld\n *\n * @param stats The stats data\n * @returns A stat modifier which caps all the vars matched to ids in stats to [0, 100]\n */\nfunction parameterCapsFromStats(stats: GameWorld['stats']) {\n    const statVarIds = stats.map((stat) => stat.id)\n    return createParameterCap(statVarIds, 0, 100)\n}\n\n/**\n * Creates a Card<Params> from regular card data or event card data\n *\n * @param data The card data\n * @param defaultParams The default parameters to use for state reset\n * @returns A runtime model of a card\n */\nfunction cardFromData(\n    data: GameWorld['cards'][number] | GameWorld['eventCards'][string],\n    defaultParams: Params,\n): Card<Params> {\n    const paramQueries = ('isAvailableWhen' in data\n        ? data.isAvailableWhen\n        : []\n    ).map(worldQueryToParamQuery)\n    return {\n        image: data.image,\n        title: data.title,\n        text: data.text,\n        location: data.location,\n        match: (s) => hasMatchingParamQuery(s.params, paramQueries),\n        weight: data.weight,\n        actions: {\n            left: actionFromData(data.actions.left, defaultParams, 'No'),\n            right: actionFromData(data.actions.right, defaultParams, 'Yes'),\n        },\n    }\n}\n\n/**\n * Creates a map of event cars from GameWorlds event card data\n *\n * @param eventCardsData The event card data\n * @param defaultParams Default params to use for a state reset\n * @returns A map of event cards\n */\nfunction eventCardsFromData(\n    eventCardsData: GameWorld['eventCards'],\n    defaultParams: Params,\n): { [x: string]: Card<Params> } {\n    const eventCards = Object.keys(eventCardsData).reduce<{\n        [x: string]: Card<Params>\n    }>((acc, key) => {\n        const data = eventCardsData[key]\n        acc[key] = cardFromData(data, defaultParams)\n        return acc\n    }, {})\n\n    for (const cardId in eventCards) {\n        const data = eventCardsData[cardId]\n        const eventCard = eventCards[cardId]\n\n        eventCard.actions.left.modifier = eventCardChain(\n            data.actions.left,\n            eventCards,\n            eventCard.actions.left.modifier,\n        )\n        eventCard.actions.right.modifier = eventCardChain(\n            data.actions.right,\n            eventCards,\n            eventCard.actions.right.modifier,\n        )\n    }\n    return eventCards\n}\n\n/**\n * Completes an event card action modifier by adding trigger for next card\n * in case a nextEventCardId is specified\n *\n * @param data The action data\n * @param eventCards An event cards map\n * @param modifier The current modifier without card trigger\n * @returns A StateModifier with conditionally added next card trigger\n */\nfunction eventCardChain(\n    data: EventCardActionData,\n    eventCards: { [x: string]: Card<Params> },\n    modifier: StateModifier<Params>,\n): StateModifier<Params> {\n    const targetCard =\n        data.nextEventCardId !== null ? eventCards[data.nextEventCardId] : null\n    return targetCard\n        ? (state) => ({\n              ...modifier(state),\n              card: targetCard,\n          })\n        : modifier\n}\n\n/**\n * Creates a card action from CardActionData\n *\n * @param data\n * @param defaultParams Default params to use when resetting state\n * @param defaultDescription The default description in case it is missing in data\n * @returns A card action with description and param modifier\n */\nfunction actionFromData(\n    data: CardActionData,\n    defaultParams: Params,\n    defaultDescription: string,\n): CardAction<Params> {\n    return {\n        description: data.description ?? defaultDescription,\n        modifier: (state) => updateParams(state, data.modifiers, defaultParams),\n    }\n}\n\n/**\n * Converts a WorldQuery to a ParamQuery\n *\n * @param query The WorldQuery\n * @returns A ParamQuery representing the input WorldQuery\n */\nfunction worldQueryToParamQuery(query: WorldQuery): ParamQuery {\n    return {\n        vars: query.state,\n        flags: query.flags,\n    }\n}\n\n/**\n * Updates the params of a GameState given a GameWorldModifier\n *\n * @param state The input GameState\n * @param modifier The modifier data description\n * @param defaultParams Default params to use for a state reset\n * @returns The updated GameState\n */\nfunction updateParams(\n    state: GameState<Params>,\n    modifiers: GameWorldModifier[],\n    defaultParams: Params,\n): GameState<Params> {\n    return {\n        ...state,\n        params: {\n            vars: modifiers.reduce(\n                (acc, modifier) =>\n                    updateVars(acc, modifier, defaultParams.vars),\n                state.params.vars,\n            ),\n            flags: modifiers.reduce(\n                (acc, modifier) =>\n                    updateFlags(acc, modifier, defaultParams.flags),\n                state.params.flags,\n            ),\n        },\n    }\n}\n\nfunction updateVars(\n    params: Params['vars'],\n    modifier: GameWorldModifier,\n    defaultVars: Params['vars'],\n): Params['vars'] {\n    const currentVars: Params['vars'] =\n        modifier.type === 'replace'\n            ? Object.assign({}, defaultVars)\n            : Object.assign({}, params)\n\n    const stateModifier = modifier.state || {}\n    const updatedWorldState = Object.entries(stateModifier).reduce<\n        Params['vars']\n    >((updatedState, [key, value]) => {\n        const newValue =\n            modifier.type === 'set' || modifier.type === 'replace'\n                ? value\n                : value + (updatedState[key] || 0)\n\n        updatedState[key] = Math.min(Math.max(newValue, 0), 100)\n\n        return updatedState\n    }, currentVars)\n\n    return updatedWorldState\n}\n\nfunction updateFlags(\n    flags: Params['flags'],\n    modifier: GameWorldModifier,\n    defaultFlags: Params['flags'],\n): Params['flags'] {\n    const currentFlags: Params['flags'] =\n        modifier.type === 'replace'\n            ? Object.assign({}, defaultFlags)\n            : Object.assign({}, flags)\n\n    const flagsModifier = modifier.flags || {}\n    const updatedWorldFlags = Object.entries(flagsModifier).reduce<\n        Params['flags']\n    >((updatedFlags, [key, value]) => {\n        updatedFlags[key] = value\n        return updatedFlags\n    }, currentFlags)\n\n    return updatedWorldFlags\n}\n","import {\n    WorldState,\n    StatDefinition,\n    CardData,\n    EventCards,\n    WorldEvent,\n    GameWorld,\n    WorldStateModifier,\n} from './ContentTypes'\n\nasync function tryLoadFromLocalStorage(\n    path: string,\n): Promise<GameWorld | null> {\n    const matchLocal = path.match(/^local:\\/\\/(.*)/)\n\n    if (matchLocal) {\n        // Import from SFF game world editor hosted on the same domain.\n        // Using localStorage to share data across apps\n        const id = matchLocal[1]\n        const gameWorldId = 'game_world:' + id\n        const gameWorld: GameWorld = {\n            stats: [],\n            cards: [],\n            events: [],\n            eventCards: {},\n            defaultState: {\n                state: {},\n                flags: {},\n            },\n            worldStateModifiers: []\n        }\n        const serializedData = localStorage.getItem(gameWorldId)\n        const data: GameWorld = serializedData\n            ? JSON.parse(serializedData)\n            : null\n        if (!data)\n            throw new Error(\n                'Could not load data from local storage: ' + gameWorldId,\n            )\n        return Object.assign(gameWorld, data)\n    }\n\n    return null\n}\n\nasync function tryLoadFromRestAPI(path: string): Promise<GameWorld | null> {\n    // Default: expect a folder to represent a GameWorld and contain specific JSON-files.\n    const statsPath = path + '/stats.json'\n    const cardsPath = path + '/cards.json'\n    const eventsPath = path + '/events.json'\n    const eventCardsPath = path + '/event-cards.json'\n    const defaultStatePath = path + '/default-state.json'\n    const worldStateModifiersPath = path + '/modifiers.json'\n\n    const [stats, cards, events, eventCards, defaultState, worldStateModifiers] = await Promise.all<\n        StatDefinition[],\n        CardData[],\n        WorldEvent[],\n        EventCards,\n        WorldState,\n        WorldStateModifier[]\n    >([\n        fetchJSON(statsPath),\n        fetchJSON(cardsPath),\n        fetchJSON(eventsPath),\n        fetchJSON(eventCardsPath),\n        fetchJSON(defaultStatePath),\n        fetchJSON(worldStateModifiersPath),\n    ])\n\n    return {\n        stats,\n        cards,\n        events,\n        eventCards,\n        defaultState,\n        worldStateModifiers,\n    }\n}\n\nexport async function loadScenario(path: string) {\n    return (\n        (await tryLoadFromLocalStorage(path)) ||\n        (await tryLoadFromRestAPI(path))\n    )\n}\n\nasync function fetchJSON<T>(path: string): Promise<T> {\n    console.log('fetching path: ', path)\n    return await (await window.fetch(path)).json()\n}\n","import React, { useState, useEffect } from 'react'\nimport styled from 'styled-components/macro'\nimport { createGlobalStyle } from 'styled-components'\n\nimport Game from './components/Game'\nimport { Game as GameLogic, BasicGameScenario } from './game'\nimport * as GameWorldLoader from './game/GameWorldLoader'\nimport { loadScenario } from './game/load-scenario'\n\nconst Container = styled.main`\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100%;\n    background: #ccdddd;\n    display: flex;\n    flex-direction: column;\n`\nconst GlobalStyles = createGlobalStyle`\n    * {\n        box-sizing: border-box;\n    }\n\n    html,\n    body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n        width: 100%;\n        user-select: none;\n        position: fixed;\n        overflow: hidden;\n    }\n`\n\ntype AppProps = {\n    path: string\n    useBasicGame?: boolean\n}\n\nfunction App({ path, useBasicGame = false }: AppProps) {\n    const [game, setGame] = useState<GameLogic<any> | null>(null)\n    useEffect(() => {\n        const fetchWorld = async () => {\n            const scenarioData = await loadScenario(path)\n            if (scenarioData) {\n                const instance = useBasicGame\n                    ? BasicGameScenario.fromData(scenarioData)\n                    : GameWorldLoader.load(scenarioData)\n                setGame(instance)\n            } else {\n                console.warn('Scenario loading error')\n            }\n        }\n        fetchWorld()\n    }, [path, useBasicGame, setGame])\n    return (\n        <Container>\n            <GlobalStyles />\n            {game && <Game game={game} />}\n        </Container>\n    )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nconst urlParams = new URLSearchParams(window.location.search)\nconst path =\n    urlParams.get('path') || process?.env?.REACT_APP_SFF_DEFAULT_SCENARIO\n\nif (path) {\n    ReactDOM.render(<App path={path} />, document.getElementById('root'))\n}\n"],"sourceRoot":""}