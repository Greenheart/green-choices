{"version":3,"sources":["util/constants.ts","components/CardView.tsx","components/Card.tsx","util/hooks.ts","components/Deck.tsx","components/Bar.tsx","components/Stats.tsx","components/Game.tsx","game/WorldStateExtensions.ts","game/GameScenario.ts","game/load-scenario.ts","App.tsx","index.tsx"],"names":["SwipeDirection","cardSize","scale","cardWidth","theme","borderRadius","cardHeight","actionWidth","minActionWidth","largePadding","halfLargePadding","quadPadding","doublePadding","mediumPadding","halfPadding","locationPosition","CardContent","styled","div","props","cardBackImage","defaultProps","value","CardView","image","title","text","location","leftAction","rightAction","direction","className","style","backgroundImage","Left","Right","DummyCard","x","y","r","layer","position","left","transform","transition","zIndex","getThreshold","Math","min","window","innerWidth","Card","keys","callback","i","cardData","onSwipe","actions","useSpring","rot","delay","to","from","cardAnimationState","setCardAnimationState","useState","directionPreview","setDirectionPreview","isGone","currentKey","cardState","gestureControl","args","down","xDelta","delta","velocity","distance","trigger","abs","devicePixelRatio","dir","sign","setTimeout","undefined","config","friction","tension","key","directionX","useEffect","downHandler","event","includes","upHandler","addEventListener","removeEventListener","bind","useGesture","interpolate","s","Number","description","right","loopingIndex","index","length","tick","Deck","card","cardStack","Array","apply","map","_","list","sin","id","Container","Value","getBarColor","Bar","width","backgroundColor","header","Stat","Icon","Stats","stats","gameIcon","icon","ioIcon","featherIcon","IconWidget","GameIcons","IoIcons","FeatherIcons","iconSize","size","Footer","footer","Game","scenario","getInitialState","state","setState","Date","now","addUniqueCardId","worldState","world","stat","Object","assign","action","getUpdatedState","rounds","worldStateRounds","flags","reduceState","targetId","sourceIds","func","initialValue","stateValues","result","reduce","acc","worldStateExtensionFromData","modifiers","modifier","type","a","b","max","stateIds","flagIds","outState","outFlags","console","table","Error","BasicGameScenario","options","_scenario","_random","_worldStateExtensions","random","worldStateExtensions","this","applyWorldStateExtensions","defaultState","getInitialCard","prevState","updatedWorld","getUpdatedWorld","getNextCard","inputModifier","updatedWorldState","updateWorldState","updatedWorldFlags","updateWorldFlags","currentWorldState","stateModifier","entries","updatedState","newValue","currentWorldFlags","flagsModifier","updatedFlags","extensions","extension","availableEvents","getAvailableEvents","selectNextEvent","selectEventCard","initialEventCardId","selectNextCard","getAvailableCards","nextCard","eventCards","availableCards","nextEventCardId","eventStartingNow","hasOwnProperty","events","filter","e","hasMatchingWorldQuery","isAvailableWhen","cards","c","worldQueries","some","q","isMatchingWorldQuery","every","flag","selectRandomFrom","probability","cardId","eventCard","array","floor","selectWeightedRandomFrom","weightFunc","element","weight","count","selectionList","push","selectionPosition","selectionIndex","findIndex","data","worldStateModifiers","tryLoadFromLocalStorage","path","matchLocal","match","gameWorldId","gameWorld","serializedData","localStorage","getItem","JSON","parse","tryLoadFromRestAPI","statsPath","cardsPath","eventsPath","eventCardsPath","defaultStatePath","worldStateModifiersPath","Promise","all","fetchJSON","loadScenario","log","fetch","json","main","GlobalStyles","createGlobalStyle","App","setScenario","scenarioData","instance","fromData","warn","fetchWorld","URLSearchParams","search","get","process","REACT_APP_SFF_DEFAULT_SCENARIO","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.7e877453.chunk.js","sourcesContent":["export enum SwipeDirection {\n    Left = -1,\n    Right = 1,\n}\n","import React from 'react'\nimport styled from 'styled-components/macro'\nimport { SwipeDirection } from '../util/constants'\n\ntype DummyCardProps = {\n    x: number\n    y: number\n    r: number\n    layer: number\n}\n\ntype CardProps = {\n    image: string\n    title: string\n    text: string\n    location: string\n    leftAction?: string\n    rightAction?: string\n    direction?: SwipeDirection\n}\n\nfunction cardSize(\n    scale: number,\n): ((props: {theme: {cardWidth: (s: number) => string}}) => string) {\n    return ({theme: {cardWidth}}: {theme: {cardWidth: (s: number) => string}}) => cardWidth(scale);\n}\n\nconst borderRadius = cardSize(0.035);\nconst cardWidth = cardSize(1);\nconst cardHeight = cardSize(2);\nconst actionWidth = cardSize(0.5);\nconst minActionWidth = cardSize(0.25);\nconst largePadding = cardSize(0.125);\nconst halfLargePadding = cardSize(0.0625);\nconst quadPadding = cardSize(0.1);\nconst doublePadding = cardSize(0.05);\nconst mediumPadding = cardSize(0.025);\nconst halfPadding = cardSize(0.0125);\nconst locationPosition = cardSize(-0.1125);\n\nconst CardContent = styled.div`\n    font-size: ${borderRadius};\n\n    & > .action-left, & > .action-right {\n        font-size: 160%;\n        background: #fff;\n        position: absolute;\n        overflow: hidden;\n        top: 20%;\n        max-width: ${actionWidth};\n        min-width: ${minActionWidth};\n\n        padding: 0;\n        opacity: 0;\n        transition: transform 0.2s, opacity 0.2s;\n        transform: translateX(0%) scale(0.7);\n        box-shadow: 0 12.5px 20px -10px rgba(50, 50, 73, 0.4),\n            0 10px 10px -10px rgba(50, 50, 73, 0.3);\n\n        & > .description {\n            padding: ${mediumPadding};\n            text-align: center;\n        }\n\n        & > .arrow {\n            background: #333;\n            font-size: 160%;\n            color: #fff;\n            padding-left: ${mediumPadding};\n            padding-right: ${mediumPadding};\n        }\n    }\n\n    & > .action-right {\n        left: 0;\n        border-radius: ${borderRadius};\n\n        & > .arrow {\n            text-align: right;\n        }\n    }\n\n    & > .action-left {\n        right: 0;\n        border-radius: ${borderRadius};\n    }\n\n    & > .action-right.active {\n        transform: translateX(-50%) scale(1);\n        opacity: 1;\n    }\n\n    & > .action-left.active {\n        transform: translateX(50%) scale(1);\n        opacity: 1;\n    }\n\n    & > .card-view {\n        display: block;\n        will-change: transform;\n        position: relative;\n        width: ${cardWidth};\n        height: ${cardHeight};\n        border-radius: ${borderRadius};\n        box-shadow: 0 12.5px 20px -10px rgba(50, 50, 73, 0.4),\n            0 10px 10px -10px rgba(50, 50, 73, 0.3);\n        overflow: hidden;\n        background: #fff;\n\n        & > .card-image {\n            width: 100%;\n            height: 70%;\n            background-repeat: no-repeat;\n            background-position: center center;\n            background-size: auto 120%;\n            border: solid ${borderRadius} #fff;\n            border-style: solid solid none solid;\n        }\n\n        & > .card-text {\n            position: absolute;\n            bottom: 0;\n            left: 0;\n            width: 100%;\n            min-height: 30%;\n            background: #fff;\n\n            & > em.location {\n                position: absolute;\n                top: ${locationPosition};\n                right: 0;\n                display: block;\n                font-size: 140%;\n                background: rgba(230, 230, 230, 0.7);\n                border-radius: 1vh 0 0 1vh;\n                padding: ${halfPadding}\n                    ${largePadding}\n                    ${halfPadding}\n                    ${doublePadding};\n            }\n\n            & > h1.title {\n                font-size: 160%;\n                white-space: nowrap;\n                color: #fff;\n                background: #333;\n                display: block;\n                margin: 0;\n                padding: ${mediumPadding}\n                    ${halfLargePadding};\n            }\n\n            & > p.text {\n                font-size: 160%;\n                color: #333;\n                padding: ${doublePadding}\n                    ${halfLargePadding}\n                    ${quadPadding}\n                    ${halfLargePadding};\n                margin: 0;\n            }\n        }\n\n        & > .card-back {\n            width: 100%;\n            height: 100%;\n            border: solid ${borderRadius} #fff;\n            box-sizing: border-box;\n            background: url(${(props) => props.theme.cardBackImage});\n            background-size: auto 100%;\n            background-repeat: repeat;\n            background-position: center center;\n        }\n    }\n`\nCardContent.defaultProps = {\n    theme: {\n        cardWidth: (value: number) => value * 40 + 'vh',\n        cardBackImage: 'https://images.unsplash.com/photo-1550537687-c91072c4792d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=800&q=80', \n    },\n}\n\nexport const CardView: React.SFC<CardProps> = ({\n    image,\n    title,\n    text,\n    location,\n    leftAction,\n    rightAction,\n    direction,\n}) => (\n    <CardContent>\n        <div className=\"card-view\">\n            <div\n                className=\"card-image\"\n                style={{\n                    backgroundImage: 'url(' + (image ? image : '') + ')',\n                }}\n            ></div>\n            <div className=\"card-text\">\n                {location && <em className=\"location\">{location}</em>}\n                <h1 className=\"title\">{title}</h1>\n                <p className=\"text\">{text}</p>\n            </div>\n        </div>\n        <div className={\"action-left\" + (direction === SwipeDirection.Left ? \" active\" : \"\")}>\n            <div className=\"description\">{leftAction ?? \"No\"}</div>\n            <div className=\"arrow\">&larr;</div>\n        </div>\n        <div className={\"action-right\" + (direction === SwipeDirection.Right ? \" active\" : \"\")}>\n            <div className=\"description\">{rightAction ?? \"Yes\"}</div>\n            <div className=\"arrow\">&rarr;</div>\n        </div>\n    </CardContent>\n)\n\nexport const DummyCard: React.FunctionComponent<DummyCardProps> = ({\n    x,\n    y,\n    r = 0,\n    layer,\n}) => (\n    <div\n        style={{\n            position: 'absolute',\n            left: '50%',\n            transform: `translate3d(-50%, 0, 0) translate3d(${x}px, ${y}px, 0) perspective(1500px) rotate3d(1, 0, 0, 30deg) rotate3d(0, 0, 1, ${r}deg)`,\n            transition: 'transform 0.3s',\n            zIndex: layer,\n        }}\n    >\n        <CardContent>\n            <div className=\"card-view\">\n                <div className=\"card-back\"></div>\n            </div>\n        </CardContent>\n    </div>\n)\n","import React, { useState } from 'react'\nimport { CardView } from './CardView'\n\nimport { animated, interpolate } from 'react-spring'\nimport { useSpring } from 'react-spring'\nimport { useGesture, GestureState } from 'react-with-gesture'\n\nimport { useKeyboardEvent } from '../util/hooks'\nimport { CardData, EventCard } from '../game/ContentTypes'\nimport { SwipeDirection } from '../util/constants'\n\ntype AnimationState = {\n    x: number\n    y: number\n    scale: number\n    rot: number\n    delay?: number\n}\n\nconst to = (i: number): AnimationState => ({\n    x: 0,\n    y: 0,\n    scale: 1,\n    rot: 0,\n    delay: i * 100,\n})\nconst from = (): AnimationState => ({ rot: 0, scale: 1.0, y: 10, x: 0 })\n\nconst trans = (r: number, s: number) =>\n    `perspective(1500px) rotate3d(1, 0, 0, 30deg) rotate3d(0, 0, 1, ${r}deg) scale(${s})`\n\nconst getDeltaX = () => getThreshold() / window.devicePixelRatio\n\nconst getThreshold = () => Math.min(200, window.innerWidth / 2)\n\ntype CardProps = {\n    i: number\n    cardData: CardData | EventCard\n    onSwipe: (card: CardData | EventCard, direction: SwipeDirection) => void\n    layer: number\n}\n\nconst Card: React.FunctionComponent<CardProps> = ({\n    i,\n    cardData,\n    onSwipe,\n    layer,\n}) => {\n    const { title, location, text, image, actions } = cardData\n\n    const [cardAnimationState, setCardAnimationState] = useSpring(() => ({\n        ...to(i),\n        from: from(),\n    }))\n    const [directionPreview, setDirectionPreview] = useState<number>(0);\n\n    const [cardState] = useState<{\n        isGone: boolean\n        currentKey: string | null\n    }>({ isGone: false, currentKey: null })\n\n    const gestureControl: (\n        state: Pick<\n            GestureState,\n            'args' | 'down' | 'delta' | 'distance' | 'direction' | 'velocity'\n        >,\n    ) => void = ({\n        args: [index],\n        down,\n        delta: [xDelta],\n        distance,\n        direction: [xDir],\n        velocity,\n    }) => {\n        const trigger =\n            Math.abs(xDelta) * window.devicePixelRatio > getThreshold()\n        const dir = Math.sign(xDelta)\n\n        if (!down && trigger && !cardState.isGone) {\n            // Handle game state updates\n            cardState.isGone = true\n            window.setTimeout(() => {\n                onSwipe(cardData, dir)\n                cardState.currentKey = null\n            }, 200)\n        }\n        setDirectionPreview(down ? dir : 0);\n        const isGone = cardState.isGone\n\n        const x = isGone ? (200 + window.innerWidth) * dir : down ? xDelta : 0\n\n        const rot = xDelta / 100 + (isGone ? dir * 10 * velocity : 0)\n        const scale = down ? 1.1 : 1\n\n        const animationState = {\n            x,\n            rot,\n            scale,\n            delay: undefined,\n            config: {\n                friction: 50,\n                tension: down ? 800 : isGone ? 200 : 500,\n            },\n        }\n\n        setCardAnimationState(animationState)\n    }\n\n    useKeyboardEvent(['ArrowLeft', 'ArrowRight'], (down, key) => {\n        if (down && !cardState.currentKey) {\n            cardState.currentKey = key\n        }\n        if (cardState.currentKey === key) {\n            const directionX =\n                key === 'ArrowLeft' ? SwipeDirection.Left : SwipeDirection.Right\n            gestureControl({\n                down,\n                delta: [directionX * (getDeltaX() + 1), 0],\n                direction: [directionX, 0],\n                args: [0],\n                distance: 0,\n                velocity: 5,\n            })\n        }\n    })\n\n    const bind = useGesture((args) => {\n        if (!cardState.currentKey) gestureControl(args)\n    })\n\n    const { x, y, rot, scale } = cardAnimationState\n\n    return (\n        <animated.div\n            {...bind(i)}\n            key={i}\n            style={{\n                position: 'absolute',\n                left: '50%',\n                transform: interpolate(\n                    [x, y, rot, scale as any],\n                    (x: number, y: number, rot: number, scale: number) =>\n                        `translate3d(-50%, 0, 0) translate3d(${x}px,${y}px,0) ` +\n                        trans(rot, Number(scale)),\n                ),\n                zIndex: layer,\n            }}\n        >\n            <CardView\n                image={image}\n                title={title}\n                text={text}\n                location={location}\n                leftAction={actions.left.description}\n                rightAction={actions.right.description}\n                direction={directionPreview}\n            />\n        </animated.div>\n    )\n}\n\nexport default Card\n","import { useEffect } from 'react'\n\nexport const useKeyboardEvent = (\n    keys: string[],\n    callback: (down: boolean, key: string) => void,\n) => {\n    useEffect(() => {\n        const downHandler = function (event: KeyboardEvent) {\n            if (keys.includes(event.key)) {\n                callback(true, event.key)\n            }\n        }\n        const upHandler = function (event: KeyboardEvent) {\n            if (keys.includes(event.key)) {\n                callback(false, event.key)\n            }\n        }\n        window.addEventListener('keydown', downHandler)\n        window.addEventListener('keyup', upHandler)\n        return () => {\n            window.removeEventListener('keydown', downHandler)\n            window.removeEventListener('keyup', upHandler)\n        }\n    })\n}\n","import React from 'react'\n\nimport Card from './Card'\nimport { DummyCard } from './CardView'\n\nimport { CardData, EventCard } from '../game/ContentTypes'\nimport { SwipeDirection } from '../util/constants'\n\ntype DeckProps = {\n    onSwipe: (card: CardData | EventCard, direction: SwipeDirection) => void\n    card: (CardData | EventCard) & { id: string }\n    tick: number\n}\nconst Deck: React.FunctionComponent<DeckProps> = ({\n    onSwipe,\n    card,\n    tick = 0,\n}) => {\n    const cardStack = Array.apply(null, Array(5)).map((_, index) => index)\n    return (\n        <div className=\"deck-root\">\n            {cardStack.map((key, index, list) => (\n                <DummyCard\n                    x={0}\n                    y={\n                        10 +\n                        list[loopingIndex(index, list.length, tick)] *\n                            (50 / list.length)\n                    }\n                    key={index}\n                    r={Math.sin(key * 2345) * 1}\n                    layer={list.length - loopingIndex(index, list.length, tick)}\n                />\n            ))}\n            <Card\n                i={0}\n                key={card.id}\n                cardData={card}\n                onSwipe={onSwipe}\n                layer={cardStack.length + 1}\n            />\n        </div>\n    )\n}\n\nfunction loopingIndex(index: number, length: number, tick: number) {\n    const result = (length + index - (tick % length)) % length\n    return result\n}\n\nexport default Deck\n","import React from 'react'\nimport styled from 'styled-components/macro'\n\nconst Container = styled.div`\n    margin-top: 10px;\n    width: 40px;\n    height: 8px;\n    border-radius: 4px;\n    background: #546a76;\n`\n\nconst Value = styled.div`\n    position: relative;\n    top: 1px;\n    left: 1px;\n    height: 6px;\n    max-width: 38px;\n    border-radius: 3px;\n`\n\ntype BarProps = {\n    value: number\n}\n\nconst Bar: React.FunctionComponent<BarProps> = ({ value = 100 }) => (\n    <Container>\n        <Value\n            style={{\n                width: `${value}%`,\n                backgroundColor: getBarColor(value),\n            }}\n        />\n    </Container>\n)\n\nfunction getBarColor(value: number): string {\n    if (value <= 30) {\n        return '#dd7373'\n    } else if (value <= 70) {\n        return '#e7e247'\n    } else {\n        return '#91c779'\n    }\n}\n\nexport default Bar\n","import React from 'react'\nimport styled from 'styled-components/macro'\n\n// This could prove to be a hit in binary size since we require all the icons in each pack. This compromise allows for more dynamic content.\nimport * as IoIcons from 'react-icons/io'\nimport * as GameIcons from 'react-icons/gi'\nimport * as FeatherIcons from 'react-icons/fi'\n\nimport Bar from './Bar'\nimport { StatDefinition } from '../game/ContentTypes'\n\nconst Container = styled.header`\n    background: #f6fbf5;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-evenly;\n    align-items: center;\n`\n\nconst Stat = styled.div`\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-direction: column;\n`\n\nconst Icon = styled.div`\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    background: #91c779;\n\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`\ntype StatsProps = {\n    stats: (StatDefinition & { value: number })[]\n}\n\nconst Stats: React.FunctionComponent<StatsProps> = ({ stats }) => (\n    <Container>\n        {stats.map((s) => {\n            const gameIcon = s.icon as keyof typeof GameIcons\n            const ioIcon = s.icon as keyof typeof IoIcons\n            const featherIcon = s.icon as keyof typeof FeatherIcons\n            const IconWidget =\n                GameIcons[gameIcon] ||\n                IoIcons[ioIcon] ||\n                FeatherIcons[featherIcon]\n            const iconSize = s.iconSize || '80%'\n            const value = s.value\n            return (\n                <Stat key={s.id}>\n                    <Icon>{IconWidget && <IconWidget size={iconSize} />}</Icon>\n                    <Bar value={value} />\n                </Stat>\n            )\n        })}\n    </Container>\n)\n\nexport default Stats\n","import React, { useState } from 'react'\nimport styled from 'styled-components/macro'\n\nimport Deck from './Deck'\nimport Stats from './Stats'\nimport { SwipeDirection } from '../util/constants'\nimport { GameScenario } from '../game/GameScenario'\nimport { CardData, EventCard } from '../game/ContentTypes'\nimport { GameState } from '../game/GameTypes'\n\nconst Footer = styled.footer`\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`\n\ntype GameProps = {\n    scenario: GameScenario\n}\n\nconst Game: React.FunctionComponent<GameProps> = ({ scenario }) => {\n    const [state, setState] = useState<GameState>(() => scenario.getInitialState())\n\n    const card = addUniqueCardId(state.card)\n    const worldState = state.world.state\n    const stats = scenario.stats.map((stat) =>\n        Object.assign({}, stat, {\n            value: worldState[stat.id],\n        }),\n    )\n\n    function onSwipe(\n        card: CardData | EventCard,\n        direction: SwipeDirection,\n    ): void {\n        const action =\n            direction === SwipeDirection.Left\n                ? card.actions.left\n                : card.actions.right\n\n        setState(scenario.getUpdatedState(state, card, action))\n    }\n\n    return (\n        <>\n            <Stats stats={stats} />\n            <Deck onSwipe={onSwipe} card={card} tick={state.rounds} />\n            <Footer>\n                <div className=\"time-remaining\"></div>\n            </Footer>\n        </>\n    )\n}\n\nfunction addUniqueCardId(\n    card: CardData | EventCard,\n    index: number = 0,\n): (CardData | EventCard) & { id: string } {\n    return {\n        ...card,\n        id: Date.now() + ':' + index,\n    }\n}\n\nexport default Game\n","import { WorldState } from './ContentTypes'\nimport { WorldStateModifier } from \"./ContentTypes\"\n\nexport type WorldStateExtension = (worldState: WorldState) => WorldState\n\n/**\n * World state extension counting the number of sounds from game start\n *\n * @param worldState The world state on which to operate\n * @returns WorldState The updated world state\n */\nexport const worldStateRounds: WorldStateExtension = (\n    worldState: WorldState,\n) => {\n    return {\n        state: {\n            ...worldState.state,\n            rounds: (worldState.state.rounds ?? 0) + 1,\n        },\n        flags: worldState.flags,\n    }\n}\n\n/**\n * Create a cyclic world state extension with a given state id\n *\n * @param id The id to which cyclic state is assigned\n * @param length The length of the cycle\n * @returns WorldStateExtension A cyclic world state extension\n */\nexport function worldStateCycle(\n    id: string,\n    length: number,\n): WorldStateExtension {\n    return (worldState: WorldState) => {\n        return {\n            state: {\n                ...worldState.state,\n                [id]: ((worldState.state[id] ?? 0) + 1) % length,\n            },\n            flags: worldState.flags,\n        }\n    }\n}\n\n/**\n * Creates a reducer for world state parameters\n * \n * @param targetId The id of the state parameter that will receive the result\n * @param sourceIds The ids of the sources that are used in the reduction\n * @param func The reducer function\n * @param initialValue The initial value to the reducer\n * @returns A world state extension that reduces a single value from multiple sources\n */\nfunction reduceState(targetId: string, sourceIds: string[], func: (a: number, b: number) => number, initialValue?: number) {\n    return (worldState: WorldState) => {\n        const stateValues = sourceIds.map(id => worldState.state[id] ?? 0);\n        const result = initialValue \n            ? stateValues.reduce((acc, value) => func(acc, value), initialValue)\n            : stateValues.reduce((acc, value) => func(acc, value))\n        return {\n            state: {\n                ...worldState.state,\n                [targetId]: result,\n            },\n            flags: worldState.flags\n        }\n    }\n}\n\n/**\n * Creates a configured debug log extension that logs either the entire world state\n * or a number of specified state or flag parameters.\n *\n * @param worldState The world state on which to operate\n * @param stateIds Optional ids of the states to log\n * @param flagIds Optional ids of the flags to log\n * @returns A configured debug world state extension that logs state and flags to tables\n */\nexport function debugLogExtension(\n    stateIds?: string[],\n    flagIds?: string[]\n): WorldStateExtension {\n    return (worldState: WorldState) => {\n        const outState = stateIds === undefined\n            ? worldState.state\n            : stateIds.reduce<WorldState['state']>((acc, id) => {\n                acc[id] = worldState.state[id]\n                return acc\n            }, {})\n        const outFlags = flagIds === undefined\n            ? worldState.flags\n            : flagIds.reduce<WorldState['flags']>((acc, id) => {\n                acc[id] = worldState.flags[id]\n                return acc\n            }, {})\n        if (Object.keys(outState).length > 0) {\n            console.table(outState)\n        }\n        if (Object.keys(outFlags).length > 0) {\n            console.table(outFlags)\n        }\n        return worldState\n    }\n}\n\n/**\n * Generate a list of world state extension from a data description\n * \n * @param modifiers Data description of modifiers which can be converted to extensions\n */\nexport function worldStateExtensionFromData(modifiers: WorldStateModifier[]): WorldStateExtension[] {\n    return modifiers.map(modifier => {\n        switch (modifier.type) {\n            case \"round\":\n                return worldStateRounds\n            case \"cycle\":\n                return worldStateCycle(modifier.id, modifier.length)\n            case \"min\":\n                return reduceState(modifier.targetId, modifier.sourceIds, (a, b) => Math.min(a, b))\n            case \"max\":\n                return reduceState(modifier.targetId, modifier.sourceIds, (a, b) => Math.max(a, b))\n            case \"sum\":\n                return reduceState(modifier.targetId, modifier.sourceIds, (a, b) => a + b, 0)\n            case \"debug\":\n                return debugLogExtension(modifier.stateIds, modifier.flagIds)\n            default: throw new Error(\"Missing modifier type: \" + (modifier as any).type) // Hack to please the linter\n        }\n    })\n}","import { GameState } from './GameTypes'\nimport {\n    GameWorld,\n    WorldState,\n    WorldQuery,\n    GameWorldModifier,\n    WorldEvent,\n    CardData,\n    EventCard,\n    CardActionData,\n    EventCardActionData,\n    EventCardId,\n} from './ContentTypes'\nimport {\n    WorldStateExtension,\n    worldStateExtensionFromData,\n} from './WorldStateExtensions'\n\nexport interface GameScenario {\n    getInitialState(): GameState\n    getUpdatedState(\n        prevState: GameState,\n        card: CardData | EventCard,\n        action: CardActionData | EventCardActionData,\n    ): GameState\n    stats: GameWorld['stats']\n}\n\nexport type GameScenarioOptions = {\n    random: () => number\n    worldStateExtensions: WorldStateExtension[]\n}\n\n/**\n * BasicGameScenario used to simulate game scenarios.\n *\n * The design goal is to keep this stateless, allowing user code to manage state.\n */\nexport class BasicGameScenario implements GameScenario {\n    protected _scenario: Omit<GameWorld, \"worldStateModifiers\">\n    protected _random: () => number\n    protected _worldStateExtensions: WorldStateExtension[]\n\n    constructor(\n        scenario: Omit<GameWorld, \"worldStateModifiers\">,\n        options: Partial<GameScenarioOptions> = {},\n    ) {\n        const {\n            random = Math.random,\n            worldStateExtensions = []\n        } = options;\n        this._scenario = scenario\n        this._random = random\n        this._worldStateExtensions = worldStateExtensions\n    }\n\n    get stats() {\n        return this._scenario.stats\n    }\n\n    /**\n     * Get the initial state for a given scenario.\n     *\n     * @param scenario The scenario default data which holds all cards, events and similar\n     */\n    getInitialState(): GameState {\n        return {\n            world: this.applyWorldStateExtensions(\n                this._worldStateExtensions,\n                this._scenario.defaultState,\n            ),\n            card: this.getInitialCard(),\n            rounds: 0,\n        }\n    }\n\n    /**\n     * Get the updated state for a scenario based on previous state and the action taken to move forward.\n     *\n     * Since all dependencies are clearly stated throughout all child functions,\n     * it's really easy to change partial data and state to get a different updated state.\n     * This could be really useful for testing, or perhaps even some kind of AI to find the optimal actions/strategy\n     *\n     * @param scenario The scenario default data which holds all cards, events and similar\n     * @param prevState The state before this update\n     * @param card The currently visible card that the player is acting upon\n     * @param action The player's choosen action for how to move forward in the game\n     */\n    getUpdatedState(\n        prevState: GameState,\n        card: CardData | EventCard,\n        action: CardActionData | EventCardActionData,\n    ): GameState {\n        const updatedWorld = this.getUpdatedWorld(\n            action.modifier,\n            prevState.world,\n        )\n\n        return {\n            world: updatedWorld,\n            card: this.getNextCard(updatedWorld, card, action),\n            rounds: prevState.rounds + 1,\n        }\n    }\n\n    getUpdatedWorld(\n        inputModifier: GameWorldModifier,\n        world: WorldState,\n    ): WorldState {\n        const modifier: GameWorldModifier = {\n            type: 'add',\n            state: {},\n            flags: {},\n            ...inputModifier,\n        }\n        const updatedWorldState = this.updateWorldState(modifier, world)\n        const updatedWorldFlags = this.updateWorldFlags(modifier, world)\n        const newWorld = this.applyWorldStateExtensions(\n            this._worldStateExtensions,\n            {\n                state: updatedWorldState,\n                flags: updatedWorldFlags,\n            },\n        )\n\n        return newWorld\n    }\n\n    updateWorldState(\n        modifier: GameWorldModifier,\n        world: WorldState,\n    ): WorldState['state'] {\n        const currentWorldState: WorldState['state'] =\n            modifier.type === 'replace'\n                ? Object.assign({}, this._scenario.defaultState.state)\n                : Object.assign({}, world.state)\n\n        const stateModifier = modifier.state || {}\n        const updatedWorldState = Object.entries(stateModifier).reduce<\n            WorldState['state']\n        >((updatedState: WorldState['state'], [key, value]) => {\n            const newValue =\n                modifier.type === 'set' || modifier.type === 'replace'\n                    ? value\n                    : value + (updatedState[key] || 0)\n\n            updatedState[key] = Math.min(Math.max(newValue, 0), 100)\n\n            return updatedState\n        }, currentWorldState)\n\n        return updatedWorldState\n    }\n\n    updateWorldFlags(\n        modifier: GameWorldModifier,\n        world: WorldState,\n    ): WorldState['flags'] {\n        const currentWorldFlags: WorldState['flags'] =\n            modifier.type === 'replace'\n                ? Object.assign({}, this._scenario.defaultState.flags)\n                : Object.assign({}, world.flags)\n\n        const flagsModifier = modifier.flags || {}\n        const updatedWorldFlags = Object.entries(flagsModifier).reduce<\n            WorldState['flags']\n        >((updatedFlags, [key, value]) => {\n            updatedFlags[key] = value\n            return updatedFlags\n        }, currentWorldFlags)\n\n        return updatedWorldFlags\n    }\n\n    applyWorldStateExtensions(\n        extensions: WorldStateExtension[],\n        world: WorldState,\n    ): WorldState {\n        return extensions.reduce((acc, extension) => extension(acc), world)\n    }\n\n    getInitialCard(): EventCard | CardData {\n        const availableEvents = this.getAvailableEvents(\n            this._scenario.defaultState,\n        )\n        const event = this.selectNextEvent(availableEvents)\n\n        if (event) {\n            return this.selectEventCard(event.initialEventCardId)\n        } else {\n            return this.selectNextCard(\n                this.getAvailableCards(this._scenario.defaultState),\n            )\n        }\n    }\n\n    getNextCard(\n        updatedWorld: WorldState,\n        card: CardData | EventCard,\n        action: CardActionData | EventCardActionData,\n    ): CardData | EventCard {\n        const { eventCards } = this._scenario\n        const availableEvents = this.getAvailableEvents(updatedWorld)\n        let availableCards: CardData[] = []\n\n        const nextEventCardId: string | null =\n            card.type === 'event' && 'nextEventCardId' in action\n                ? action.nextEventCardId\n                : null\n        const eventStartingNow = !nextEventCardId\n            ? this.selectNextEvent(availableEvents)\n            : null\n        let nextCard\n\n        // Only select the next EventCard if a specific one is given\n        // Else cancel the event and continue with normal cards.\n        if (nextEventCardId) {\n            if (!eventCards.hasOwnProperty(nextEventCardId)) {\n                throw new Error(\n                    `eventCardId \"${nextEventCardId}\" does not exist. Make sure it's spelled correctly`,\n                )\n            }\n            nextCard = this.selectEventCard(nextEventCardId)\n        } else if (eventStartingNow) {\n            nextCard = this.selectEventCard(eventStartingNow.initialEventCardId)\n        } else {\n            availableCards = this.getAvailableCards(updatedWorld)\n            nextCard = this.selectNextCard(availableCards)\n        }\n\n        if (!nextCard) throw new Error('Content error. No next card available.')\n        return nextCard\n    }\n\n    getAvailableEvents(world: WorldState): WorldEvent[] {\n        const { events } = this._scenario\n        return events.filter((e) =>\n            this.hasMatchingWorldQuery(world, e.isAvailableWhen),\n        )\n    }\n\n    getAvailableCards(world: WorldState): CardData[] {\n        const { cards } = this._scenario\n        return cards.filter((c) =>\n            this.hasMatchingWorldQuery(world, c.isAvailableWhen),\n        )\n    }\n\n    hasMatchingWorldQuery(\n        world: WorldState,\n        worldQueries: WorldQuery[],\n    ): Boolean {\n        return worldQueries.some((q) => this.isMatchingWorldQuery(world, q))\n    }\n\n    isMatchingWorldQuery(\n        world: WorldState,\n        { state = {}, flags = {} }: WorldQuery,\n    ): Boolean {\n        const hasStateMatch = Object.entries(state).every(\n            ([key, [min, max]]) =>\n                world.state[key] >= min && world.state[key] <= max,\n        )\n\n        const result =\n            hasStateMatch &&\n            Object.entries(flags).every(\n                ([flag, value]) => world.flags[flag] === value,\n            )\n\n        return result\n    }\n\n    selectNextEvent(events: WorldEvent[] = []): WorldEvent | undefined {\n        const event = this.selectRandomFrom(events)\n        if (event && this._random() <= event.probability) {\n            return event\n        }\n    }\n\n    selectEventCard(cardId: EventCardId): EventCard {\n        const eventCard = this._scenario.eventCards[cardId]\n        if (!eventCard)\n            throw new Error(\n                `ContentError: EventCard with EventCardId \"${cardId}\" does not exist`,\n            )\n        return eventCard\n    }\n\n    selectRandomFrom<T>(array: T[]): T {\n        return array[Math.floor(this._random() * array.length)]\n    }\n\n    selectNextCard(cards: CardData[] = []): CardData {\n        return this.selectWeightedRandomFrom(cards)\n    }\n\n    selectWeightedRandomFrom<T extends { weight: number }>(\n        array: T[],\n        weightFunc = (element: T) => element.weight,\n    ): T {\n        const { selectionList, count } = array.reduce<{\n            count: number\n            selectionList: number[]\n        }>(\n            (acc, element) => {\n                acc.count += weightFunc(element)\n                acc.selectionList.push(acc.count)\n                return acc\n            },\n            { count: 0, selectionList: [] },\n        )\n\n        const selectionPosition = this._random() * count\n        const selectionIndex = selectionList.findIndex((max, index, array) => {\n            const min = index > 0 ? array[index - 1] : 0\n            return selectionPosition >= min && selectionPosition <= max\n        })\n\n        return array[selectionIndex]\n    }\n\n    /**\n     * Create a runtime GameScenario from data\n     * \n     * @param data Data needed to setup a basic game scenario\n     */\n    public static fromData(data: GameWorld): GameScenario {\n        const extensions = worldStateExtensionFromData(data.worldStateModifiers)\n        return new BasicGameScenario(data, {worldStateExtensions: extensions});\n    }\n}\n","import {\n    WorldState,\n    StatDefinition,\n    CardData,\n    EventCards,\n    WorldEvent,\n    GameWorld,\n    WorldStateModifier,\n} from './ContentTypes'\n\nasync function tryLoadFromLocalStorage(\n    path: string,\n): Promise<GameWorld | null> {\n    const matchLocal = path.match(/^local:\\/\\/(.*)/)\n\n    if (matchLocal) {\n        // Import from SFF game world editor hosted on the same domain.\n        // Using localStorage to share data across apps\n        const id = matchLocal[1]\n        const gameWorldId = 'game_world:' + id\n        const gameWorld: GameWorld = {\n            stats: [],\n            cards: [],\n            events: [],\n            eventCards: {},\n            defaultState: {\n                state: {},\n                flags: {},\n            },\n            worldStateModifiers: []\n        }\n        const serializedData = localStorage.getItem(gameWorldId)\n        const data: GameWorld = serializedData\n            ? JSON.parse(serializedData)\n            : null\n        if (!data)\n            throw new Error(\n                'Could not load data from local storage: ' + gameWorldId,\n            )\n        return Object.assign(gameWorld, data)\n    }\n\n    return null\n}\n\nasync function tryLoadFromRestAPI(path: string): Promise<GameWorld | null> {\n    // Default: expect a folder to represent a GameWorld and contain specific JSON-files.\n    const statsPath = path + '/stats.json'\n    const cardsPath = path + '/cards.json'\n    const eventsPath = path + '/events.json'\n    const eventCardsPath = path + '/event-cards.json'\n    const defaultStatePath = path + '/default-state.json'\n    const worldStateModifiersPath = path + '/modifiers.json'\n\n    const [stats, cards, events, eventCards, defaultState, worldStateModifiers] = await Promise.all<\n        StatDefinition[],\n        CardData[],\n        WorldEvent[],\n        EventCards,\n        WorldState,\n        WorldStateModifier[]\n    >([\n        fetchJSON(statsPath),\n        fetchJSON(cardsPath),\n        fetchJSON(eventsPath),\n        fetchJSON(eventCardsPath),\n        fetchJSON(defaultStatePath),\n        fetchJSON(worldStateModifiersPath),\n    ])\n\n    return {\n        stats,\n        cards,\n        events,\n        eventCards,\n        defaultState,\n        worldStateModifiers,\n    }\n}\n\nexport async function loadScenario(path: string) {\n    return (\n        (await tryLoadFromLocalStorage(path)) ||\n        (await tryLoadFromRestAPI(path))\n    )\n}\n\nasync function fetchJSON<T>(path: string): Promise<T> {\n    console.log('fetching path: ', path)\n    return await (await window.fetch(path)).json()\n}\n","import React, { useState, useEffect } from 'react'\nimport styled from 'styled-components/macro'\nimport { createGlobalStyle } from 'styled-components'\n\nimport Game from './components/Game'\nimport { GameScenario, BasicGameScenario } from './game/GameScenario'\nimport { loadScenario } from './game/load-scenario'\n\nconst Container = styled.main`\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100%;\n    background: #546a76;\n    display: grid;\n    grid-template-rows: minmax(50px, 80px) auto minmax(50px, 80px);\n`\nconst GlobalStyles = createGlobalStyle`\n    * {\n        box-sizing: border-box;\n    }\n\n    html,\n    body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n        width: 100%;\n        user-select: none;\n        position: fixed;\n        overflow: hidden;\n    }\n`\n\ntype AppProps = {\n    path: string\n}\n\nfunction App({ path }: AppProps) {\n    const [scenario, setScenario] = useState<GameScenario | null>(null)\n    useEffect(() => {\n        const fetchWorld = async () => {\n            const scenarioData = await loadScenario(path)\n            if (scenarioData) {\n                const instance = BasicGameScenario.fromData(scenarioData)\n                setScenario(instance)\n            } else {\n                console.warn('Scenario loading error')\n            }\n        }\n        fetchWorld()\n    }, [path, setScenario])\n    return (\n        <Container>\n            <GlobalStyles />\n            {scenario && <Game scenario={scenario} />}\n        </Container>\n    )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nconst urlParams = new URLSearchParams(window.location.search)\nconst path = (\n    urlParams.get('path') ||\n    process?.env?.REACT_APP_SFF_DEFAULT_SCENARIO ||\n    '/data/default'\n)\n\nReactDOM.render(<App path={path} />, document.getElementById('root'))\n"],"sourceRoot":""}